namespace noos {
namespace cloud {

template <class... services>
vision_batch<services...>::vision_batch(
                                         const noos::object::picture & image,
                                         services... args
                                       )
: http_request(cloud_base<bool>::make_http_uri("vision_batch")), 
  cloud_base<bool>(true),
  image__(image),
  batch__(std::make_tuple((args)...))
{
    http_request::make_multipart_form();
    std::string fname = noos::misc::random_boundary() + "." + image__.type();
    http_request::add_content("file", fname, image.bytearray());
    misc::for_each_arg([&](const auto & pair) {
        static_assert(pair.first.is_single_callable(),
                      "you can't use single callable objects in a vision batch");
        using cloud_type = typename decltype(obj)::value_type;
        static_assert(!std::is_base_of<vision_base, cloud_type>::value,
                  "cloud class must be a vision class for vision_batch");
        http_request::add_content(pair.first.uri, pair.first.json, true);
    }, args...);
    http_request::close();
}

template <class... services>
void vision_batch<services...>::process(std::string json)
{
    if (json.empty()) {
        throw std::runtime_error("empty json reply");
    }
    nlohmann::json nlohmann_json;
    try {
        nlohmann_json = json::parse(json);
    }
    catch (std::exception & e) {
        std::cerr << e.what() << std::endl;
    }
    constexpr auto tuple_size = std::tuple_size<decltype(batch__)>::value;
    for (auto json_object : nlohmann_json) {
		for (json::iterator it = json_object.begin(); it != json_object.end(); ++it) {
            std::string json = it.value().dump(-1);
            expand_batch(json, 
                         it.key(), 
                         std::make_index_sequence<tuple_size>());
        }
    }
}

template<std::size_t... batch_size>
void vision_batch<services...>::expand_batch(
                                              std::string json, 
                                              std::string key,
                                              std::index_sequence<batch_size...>
                                            ) 
{
    find_cloud_type(std::get<batch_size>(batch__)..., json, key);
}

template <class... services>
void vision_batch<services...>::find_cloud_type(
                                                  services... args, 
                                                  std::string json, 
                                                  std::string key
                                               )
{
    misc::for_each_arg([&](auto & pair){
        if (pair.first.uri == key) {
            // TODO: find type of object and deserialize result,
            //
            //       using cloud_type = typename decltype(pair.first)::value_type;
            //       using data_type  = typename cloud_type::data_type;
            //
            //       pair.second(deserialize<cloud_type, data_type>(json))
        }
    }, args...);
}

}
}
